use std::ffi::{CStr, NulError};
use std::error::Error;
use std::io;
use std::fmt::{Display, Formatter, Result as FmtResult};
use std::str::Utf8Error;

use ffi;

/// Represents any errors that can be encountered by the Assimp library
#[derive(Debug)]
pub enum AiError {
    Io(io::Error),
    Utf8Error(Utf8Error),
    NulError(NulError),
    Internal(String),
    InvalidScene
}

/// Generic Result type with an `AiError` for the error type
pub type AiResult<T> = Result<T, AiError>;

impl AiError {
    /// Checks Assimp for errors generated by previous operations, and returns an `AiResult`
    pub fn check() -> AiResult<()> {
        let err_str = unsafe { ffi::aiGetErrorString() };

        if !err_str.is_null() {
            let err = unsafe { CStr::from_ptr(err_str) }.to_string_lossy();

            if err.len() > 0 {
                return Err(AiError::Internal(err.to_string()));
            }
        }

        Ok(())
    }
}

/// This performs a `try!(AiError::check())` in place, with or without a condition
//#[macro_export]
macro_rules! check_assimp_errors {
    () => { try!(AiError::check()) };

    ($condition:expr) => {
        if $condition { try!(AiError::check()) }
    };
}

impl Display for AiError {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(f, "{}", self.description())
    }
}

impl From<io::Error> for AiError {
    fn from(err: io::Error) -> AiError {
        AiError::Io(err)
    }
}

impl From<Utf8Error> for AiError {
    fn from(err: Utf8Error) -> AiError {
        AiError::Utf8Error(err)
    }
}

impl From<NulError> for AiError {
    fn from(err: NulError) -> AiError {
        AiError::NulError(err)
    }
}

impl Error for AiError {
    fn description(&self) -> &str {
        match *self {
            AiError::Io(ref err) => err.description(),
            AiError::Utf8Error(ref err) => err.description(),
            AiError::NulError(ref err) => err.description(),
            AiError::Internal(ref err) => err,
            AiError::InvalidScene => "Invalid Scene"
        }
    }

    #[inline]
    fn cause(&self) -> Option<&Error> {
        match *self {
            AiError::Io(ref err) => Some(err),
            AiError::Utf8Error(ref err) => Some(err),
            _ => None
        }
    }
}